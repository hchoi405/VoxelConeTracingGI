#version 430

#extension GL_ARB_shading_language_include : enable
#extension GL_ARB_shader_image_load_store : require

#define VOXEL_TEXTURE_WITH_BORDER

#include "/voxelConeTracing/conversion.glsl"
#include "/voxelConeTracing/settings.glsl"
#include "/voxelConeTracing/common.glsl"

uniform sampler3D u_voxelOpacity;
uniform layout(rgba8) image3D u_voxelDiffuse;
uniform layout(rgba8) image3D u_voxelSpecularA;

uniform ivec3 u_imageMin;
uniform ivec3 u_regionMin;
uniform float u_voxelSizeL0;
uniform vec3 u_volumeCenterL0;
uniform float u_traceStartOffset;
uniform float u_stepFactor;
uniform float u_occlusionDecay;
uniform float u_indirectDiffuseIntensity;

uniform float u_shininess;
uniform vec4 u_diffuseColor;
uniform vec3 u_specularColor;

uniform int u_clipmapResolution;
uniform int u_clipmapResolutionWithBorder;
uniform int u_clipmapLevel;

vec3 worldPosFromVoxelPos(ivec3 posV)
{
    vec4 p = vec4(vec3(posV) * u_voxelSizeL0, 1.0);
    return p.xyz;
}

ivec3 toImageCoords(ivec3 p, int resolution)
{
	return (p + ivec3(resolution) * (abs(p / resolution) + 1)) & (resolution - 1); // & (resolution - 1) is a more efficient % resolution
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main()
{   
    // vec3 diffuse = texture(u_diffuseTexture, In.texCoords).rgb;

	ivec3 pos = ivec3(gl_GlobalInvocationID);
	ivec3 posV = pos + u_regionMin;
    ivec3 imagePos = toImageCoords(posV, u_clipmapResolution);
    vec3 posW = worldPosFromVoxelPos(posV);

#ifdef VOXEL_TEXTURE_WITH_BORDER
	imagePos += ivec3(BORDER_WIDTH);
#endif

    // for (int i=0; i<6; ++i) 
    // {
    //     if (texelFetch(u_voxelOpacity, imagePos, 0) == 0.0) { // zero opacity == no face
            // imageStore(u_voxelDiffuse, imagePos, vec4(0.0));
            // imageStore(u_voxelSpecularA, imagePos, vec4(0.0));
    //     }
    //     else {
    //         imageStore(u_voxelDiffuse, imagePos, vec4(vec3(posW), 1));
    //         imageStore(u_voxelSpecularA, imagePos, vec4(vec3(posW), 1));
    //     }
    //     imagePos.x += u_clipmapResolutionWithBorder;
    // }
    // return;

	imagePos.y += u_clipmapResolutionWithBorder * u_clipmapLevel;
    
    for (int j = 0; j < 6; ++j)
    {
        vec4 opacity = texelFetch(u_voxelOpacity, imagePos, 0);
        if (opacity == 0.0) { // zero opacity == no face
            imageStore(u_voxelDiffuse, imagePos, vec4(0.0));
            imageStore(u_voxelSpecularA, imagePos, vec4(0.0));        
            continue;
        }
    
        imageStore(u_voxelDiffuse, imagePos, vec4(u_diffuseColor.rgb, 1.0));
        imageStore(u_voxelSpecularA, imagePos, vec4(u_specularColor, u_shininess));

        imagePos.x += u_clipmapResolutionWithBorder;
    }
}
